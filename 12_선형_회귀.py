# -*- coding: utf-8 -*-
"""12. 선형 회귀.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eI0OjZzQUn0osZnwIC8UemJtRzO8EXkh

# **1. Rent 데이터셋**
"""

import numpy as np
import pandas as pd
import seaborn as sns

from google.colab import drive
drive.mount('/content/drive')

rent_df = pd.read_csv('/content/drive/MyDrive/컴퓨터비전_시즌2/3. 데이터 분석/Data/rent.csv')
rent_df

rent_df.info()

"""* Posted On: 매물 등록 날짜
* BHK: 베드, 홀, 키친의 개수
* Rent: 렌트비
* Size: 집 크기
* Floor: 총 층수 중 몇층
* Area Type: 공용공간을 포함하는지, 집의 면적만 포함하는지
* Area Locality: 지역
* City: 도시
* Furnishing Status: 풀옵션 여부
* Tenant Preferred: 선호하는 가족형태
* Bathroom: 화장실 개수
* Point of Contact: 연락할 곳
"""

rent_df.describe()

round(rent_df.describe(), 2)

sns.displot(rent_df['BHK'])

sns.displot(rent_df['Rent'])

rent_df['Rent'].sort_values()

sns.boxplot(y=rent_df['Rent']) # 1837 데이터는 이상치라고 예상됨

rent_df.isna().sum()

rent_df.isna().mean()

rent_df.dropna(subset=['BHK']) # BHK에 NaN이 있는 행만 삭제

na_index = rent_df[rent_df['Size'].isna()].index
na_index

rent_df['Size'].fillna(rent_df['Size'].median()).loc[na_index]

rent_df = rent_df.fillna(rent_df.median(numeric_only=True))

rent_df.isna().mean()

rent_df.info()

rent_df['Floor'].value_counts()

rent_df['Area Type'].value_counts()

rent_df['Area Type'].nunique()

rent_df['Area Type'].unique()

for i in ['Floor', 'Area Type', 'Area Locality', 'City', 'Furnishing Status', 'Tenant Preferred', 'Point of Contact']:
    print(i, rent_df[i].nunique())

rent_df.drop(['Floor', 'Area Locality', 'Tenant Preferred', 'Point of Contact', 'Posted On'], axis=1, inplace=True)

rent_df.info()

rent_df = pd.get_dummies(rent_df, columns=['Area Type', 'City', 'Furnishing Status'])
rent_df.head()

X = rent_df.drop('Rent', axis=1) # 독립변수
y = rent_df['Rent'] # 종속변수

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=2024)

X_train.shape, X_test.shape

y_train.shape, y_test.shape

"""# **2. 선형 회귀(Linear Regression)**
* 데이터를 통해 데이터를 가장 잘 설명할 수 있는 직선으로 데이터를 분석하는 방법
  * 단순 선형 회귀 분석(단일 독립변수를 이용)
  * 다중 선형 회귀 분석(다중 독립변수를 이용)
"""

from sklearn.linear_model import LinearRegression

lr = LinearRegression()

lr.fit(X_train, y_train)

pred = lr.predict(X_test) # 예측

"""# **3. 평가 지표(오차) 만들기**

### 3-1. MSE(Mean Squared Error)
* 예측값과 실제값의 차이에 대한 제곱에 대해 평균을 낸 값
* ${(\frac{1}{n})\sum_{i=1}^{n}(y_{i} - x_{i})^{2}}$
"""

p = np.array([3, 4, 5]) # 예측값
act = np.array([1, 2, 3]) # 실제값

def my_mse(pred, actual):
  return ((pred - actual) **2).mean()

my_mse(p, act)

"""### 3-2. MAE(Mean Absolute Error)
* 예측값과 실제값의 차이에 대한 절대값에 대해 평균을 낸 값
* $(\frac{1}{n})\sum_{i=1}^{n}\left | y_{i} - x_{i} \right |$
* 절대값은 미분이 어렵기 때문에 알고리즘 만들 때 잘 사용하지 않음
"""

def my_mae(pred, actual):
  return np.abs(pred - actual).mean()

my_mae(p, act)

"""### 3-3. RMSE(Root Mean Squared Error)
* 예측값과 실제값의 차이에 대한 제곱에 대해 평균을 낸 후 루트를 씌운 값
* $\sqrt{(\frac{1}{n})\sum_{i=1}^{n}(y_{i} - x_{i})^{2}}$
* 숫자가 적어지기 때문에 MSE보다 조금 더 선호됨.
"""

def my_rmse(pred, actual):
  return np.sqrt(my_mse(pred, actual))

my_rmse(p, act)

from sklearn.metrics import mean_absolute_error, mean_squared_error

mean_absolute_error(p, act)

mean_squared_error(p, act)

mean_squared_error(p, act, squared=False) # RMSE

"""### 3-4. 평가 지표 적용하기"""

mean_squared_error(y_test, pred)

mean_absolute_error(y_test, pred)

mean_squared_error(y_test, pred, squared = False)

X_train.drop(1837, inplace = True) # 이상치 제거
y_train.drop(1837, inplace = True) # 이상치 제거에 에러가 있다면 test데이터에 들어갔다는 의미이기 때문에 다시 분리해줘야함

lr2 = LinearRegression() # 전이학습 방지를 위해 새로운 객체 생성

lr2.fit(X_train, y_train)

pred2 = lr2.predict(X_test)

mean_squared_error(y_test, pred2, squared = False)

# pred rmse: 37765.125980605386 (이상치 삭제 전)
# pred2 rmse: 37731.275512059074 (이상치 삭제 후)
37765.125980605386 - 37731.275512059074 # 오차값이 줄었으므로 이상치 제거를 통해 성능이 좋아졌다고 볼 수 있다.

