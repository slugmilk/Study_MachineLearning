# -*- coding: utf-8 -*-
"""16. 랜덤 포레스트.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19uIMTFEs6xZS3Fi13fjI8bvW-_pycShb

# **1. hotel 데이터셋**
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

hotel_df = pd.read_csv('/content/drive/MyDrive/컴퓨터비전 시즌2/3. 데이터 분석/Data/hotel.csv')
hotel_df.head()

hotel_df.info()

"""* hotel: 호텔 종류
* is_canceled: 취소 여부
* lead_time: 예약 시점으로부터 체크인 될 때까지의 기간(얼마나 미리 예약했는지)
* arrival_date_year: 예약 연도
* arrival_date_month: 예약 월
* arrival_date_week_number: 예약 주
* arrival_date_day_of_month: 예약 일
* stays_in_weekend_nights: 주말을 끼고 얼마나 묶었는지
* stays_in_week_nights: 평일을 끼고 얼마나 묶었는지
* adults: 성인 인원수
* children: 어린이 인원수
* babies: 아기 인원수
* meal: 식사 형태
* country: 지역
* distribution_channel: 어떤 방식으로 예약했는지
* is_repeated_guest: 예약한적이 있는 고객인지
* previous_cancellations: 몇번 예약을 취소했었는지
* previous_bookings_not_canceled: 예약을 취소하지 않고 정상 숙박한 횟수
* reserved_room_type: 희망한 룸타입
* assigned_room_type: 실제 배정된 룸타입
* booking_changes: 예약 후 서비스가 몇번 변경되었는지
* deposit_type: 요금 납부 방식
* days_in_waiting_list: 예약을 위해 기다린 날짜
* customer_type: 고객 타입
* adr: 특정일에 높아지거나 낮아지는 가격
* required_car_parking_spaces: 주차공간을 요구했는지
* total_of_special_requests: 특별한 별도의 요청사항이 있는지
* reservation_status_date: 예약한 날짜
* name: 이름
* email: 이메일
* phone-number: 전화번호
* credit_card: 카드번호
"""

hotel_df.drop(['name', 'email', 'phone-number', 'credit_card', 'reservation_status_date'], axis=1, inplace=True)
hotel_df.head()

hotel_df.describe()

sns.displot(hotel_df['lead_time'])

sns.boxplot(hotel_df['lead_time'])

sns.barplot(x=hotel_df['distribution_channel'], y=hotel_df['is_canceled'])

hotel_df['distribution_channel'].value_counts()

sns.barplot(x=hotel_df['hotel'], y=hotel_df['is_canceled'])

sns.barplot(x=hotel_df['arrival_date_year'], y=hotel_df['is_canceled'])

plt.figure(figsize=(15, 5))
sns.barplot(x=hotel_df['arrival_date_month'], y=hotel_df['is_canceled'])

import calendar

print(calendar.month_name[1])
print(calendar.month_name[2])
print(calendar.month_name[3])

months = []
for i in range(1, 13):
    months.append(calendar.month_name[i])

months

plt.figure(figsize=(15, 5))
sns.barplot(x=hotel_df['arrival_date_month'], y=hotel_df['is_canceled'], order=months)

sns.barplot(x=hotel_df['is_repeated_guest'], y=hotel_df['is_canceled'])

sns.barplot(x=hotel_df['deposit_type'], y=hotel_df['is_canceled'])

hotel_df['deposit_type'].value_counts()

# corr(): 열들 간의 상관관계를 계산하는 함수 (피어슨 상관계수)
# -1 ~ 1까지의 범위를 가지며 0에 가까울수록 두 변수의 상관관계가 없거나 매우 약함
hotel_df.corr(numeric_only=True)

plt.figure(figsize=(15, 15))
sns.heatmap(hotel_df.corr(numeric_only=True), cmap='coolwarm', vmax=1, vmin=-1, annot=True)

hotel_df.isna().mean()

hotel_df = hotel_df.dropna()

hotel_df.head()

hotel_df[hotel_df['adults'] == 0]

# people 파생변수
hotel_df['people'] = hotel_df['adults'] + hotel_df['children'] + hotel_df['babies']
hotel_df.head()

hotel_df[hotel_df['people'] == 0]

hotel_df = hotel_df[hotel_df['people'] != 0]
hotel_df

hotel_df['total_nights'] = hotel_df['stays_in_week_nights'] + hotel_df['stays_in_weekend_nights']
hotel_df.head()

# season 파생변수
# arrival_date_month에 따라 아래와 같이 값을 저장
# 12, 1, 2: winter
# 3, 4, 5: spring
# 6, 7, 8: summer
# 9, 10, 11: fall
season_dic = {'spring':[3, 4, 5], 'summer': [6, 7, 8], 'fall': [9, 10, 11], 'winter': [12, 1, 2]}

new_season_dic = {}

for i in season_dic:
    for j in season_dic[i]:
        new_season_dic[calendar.month_name[j]] = i

new_season_dic

hotel_df['season'] = hotel_df['arrival_date_month'].map(new_season_dic)
hotel_df.head()

hotel_df.info()

hotel_df['expected_room_type'] = (hotel_df['reserved_room_type'] == hotel_df['assigned_room_type']).astype(int)
hotel_df.head()

hotel_df['cancel_rate'] = hotel_df['previous_cancellations'] / (hotel_df['previous_cancellations'] + hotel_df['previous_bookings_not_canceled'])
hotel_df.head()

hotel_df[hotel_df['cancel_rate'].isna()]

hotel_df['cancel_rate'] = hotel_df['cancel_rate'].fillna(-1)

hotel_df.head()

hotel_df.info()

hotel_df['hotel'].dtype

hotel_df['is_canceled'].dtype

hotel_df['children'].dtype

obj_list = []

for i in hotel_df.columns:
    if hotel_df[i].dtype == 'O':
        obj_list.append(i)

obj_list

for i in obj_list:
    print(i, hotel_df[i].nunique())

hotel_df.drop(['country', 'arrival_date_month'], axis=1, inplace=True)

obj_list.remove('country')
obj_list.remove('arrival_date_month')

hotel_df = pd.get_dummies(hotel_df, columns=obj_list)
hotel_df.head()

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(hotel_df.drop('is_canceled', axis=1), hotel_df['is_canceled'], test_size=0.3, random_state=2024)

X_train.shape, y_train.shape

X_test.shape, y_test.shape

"""# **2. 앙상블(ensemble) 모델**
* 여러개의 머신러닝 모델을 이용해 최적의 답을 찾아내는 기법을 사용하는 모델
* 보팅(Voting)
    * 서로 다른 알고리즘 model을 조합해서 사용
    * 모델에 대해 투표로 결과를 도출
* 배깅(Bagging)
    * 같은 알고리즘 내에서 다른 sample 조합을 사용
    * 샘플 중복 생성을 통해 결과를 도출
* 부스팅(Boosting)
    * 약한 학습기들을 순차적으로 학습시켜 강력한 학습기를 만듦
    * 이전 오차를 보완해가면서 가중치를 부여
    * 성능이 우수하지만 잘못된 레이블이나 아웃라이어에 대해 필요이상으로 민감
    * AdaBoost, Gradient Boosting, XGBoost, LightGBM
* 스태킹(Stacking)
    * 다양한 개별 모델들을 조합하여 새로운 모델을 생성
    * 다양한 모델들을 학습시켜 예측 결과를 얻은 다음, 다양한 모델들의 예측 결과를 입력으로 새로운 메타 모델을 학습

# **3. 랜덤 포레스트(Random Forest)**
* 머신러닝에서 많이 사용되는 앙상블 기법 중 하나이며, 결정 나무를 기반으로 함
* 학습을 통해 구성해 놓은 결정 나무로부터 분류 결과를 취합해서 결론을 얻는 방식
* 랜덤 포레스트의 트리는 원본 데이터에서 무작위로 선택된 샘플을 기반으로 학습함
* 각 트리가 서로 다른 데이터셋으로 학습되어 다양한 트리가 생성되며 모델의 다양성이 증가함
* 각각의 트리가 예측한 결과를 기반으로 다수결 또는 평균을 이용하여 최종 예측을 수행함
* 분류와 회귀 문제에 모두 사용할 수 있으며, 특히 데이터가 많고 복잡한 경우에 매우 효과적인 모델
* 성능은 꽤 우수한 편이나 오버피팅 하는 경향이 있음
"""

from sklearn.ensemble import RandomForestClassifier

rf = RandomForestClassifier(random_state=2024)

rf.fit(X_train, y_train)

pred1 = rf.predict(X_test)
pred1

preba1 = rf.predict_proba(X_test)
preba1

# 첫번째 테스트 데이터에 대한 예측 결과
preba1[0]

# 모든 테스트 데이터에 대한 호텔 예약을 취소할 확률만 출력
preba1[:, 1]

